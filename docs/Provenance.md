# Provenance & Runtime Enforcement

## JSON Contracts

### `scripts.provtools` – build

```
{
  "event": "build",
  "ok": true,
  "file": "docs/policy.md",
  "dsse": "attestations/policy.dsse",
  "trace_id": "…",
  "duration_ms": 12
}
```

### `scripts.provtools` – verify

```
{
  "event": "verify",
  "signature_ok": true,
  "schema_ok": true,
  "digest_ok": true,
  "statement_ok": true,
  "error_code": "OK",
  "errors": [],
  "dsse": "attestations/policy.dsse",
  "trace_id": "…",
  "duration_ms": 8
}
```

### `scripts.policy_synth_pipeline`

```
{
  "ok": true,
  "artifact": "docs/policy.md",
  "attestation": "attestations/policy.dsse",
  "verify": {
    "signature_ok": true,
    "schema_ok": true,
    "digest_ok": true,
    "error_code": "OK",
    "errors": []
  },
  "verify_exit_code": 0
}
```

## CI Summary Artifact

* Generated by `.github/workflows/provenance.yml`
* Location: `attestations/ci/summary.json`
* Gate condition: for each Markdown document with a provenance header, `signature_ok && schema_ok && digest_ok` must hold.
* On failure the workflow uploads `summary.json` and all DSSE envelopes for inspection.

## Runtime Guard usage

```
from pathlib import Path
from scripts.runtime_guard import RuntimeGuard, ScopeError

guard = RuntimeGuard.from_alou("org/_registry/AGENT-PO01.alou.md", base_dir=".")

# wrap MCP calls
wrapped = guard.wrap_tool_call(raw_tool_call)

# guarded filesystem writes
try:
    guard.fs.write_text(Path("org/policy/new-policy.md"), "# Draft\n")
except ScopeError as exc:
    log.error("write denied", extra={"error": str(exc)})
```

The guard enforces:

* MCP endpoints (`mcp_allow`)
* Filesystem write scopes (`fs_write_scopes`)
* No absolute/tilde paths, symlinks, or base-dir escapes

Always inject the guarded FS/tool wrappers into the agent runtime to prevent bypassing these checks.
